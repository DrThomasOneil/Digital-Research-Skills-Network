[["index.html", "Introduction to R and analytic Programming Welcome!", " Introduction to R and analytic Programming Yuchen Li &amp; Thomas O’Neil 2024-12-23 (Last update: 2025-01-29) Welcome! This is the sub-repository containing the tutorials and workshop notes for the introduction to R and analytic programming. Get started → "],["introduction.html", "Introduction Transitioning from manual tools (e.g. Excel &amp; Prism) to programming-based workflows in R. Handling data - be specific! Directories Reproducibility and automation", " Introduction Leaving behind manual analysis tools Goals: Introduce programming concepts and the mindset behind programmatic workflows.   • Transition from manual tools (e.g. Excel &amp; Prism) to programming-based workflows in R.   • Understand the concept of handling data using code.   • Learn to navigate directories and file paths programmatically.   • Emphasise reproducibility and structured workflows. You will not be writing any code in this introduction. Instead, we will focus on reframing how you approach analytic programming. These ideas are tailored to researchers who manage a variety of tools — FlowJo, Excel, Prism, and more — but want to unify data wrangling, visualisation, and reporting under a single environment. Read time: 10 Minutes Transitioning from manual tools (e.g. Excel &amp; Prism) to programming-based workflows in R. Many resources teach the basics of R programming, but here we view things through the lens of a wet-lab researcher dealing with biomedical data. We will go beyond basic statistical methods or standard single-cell workflows and include topics like building a lab notebook in R and collaborating with PIs or peers. If, however, all you need is a quick, “click-and-run” script to load already processed data, you might prefer resources such as this and that. Note: If you still do not get it, don’t worry. It took me years to feel comfortable. I was fortunate enough to have a supervisor who gave me time to learn this. Keep up with it, find more resources and stick with a good community of users :) Consistency Consistency is key. You won’t get significantly more efficient without practice. You may find that when you routinely use a particular analysis, you can rewrite the entire workflow from memory. But after a break, it’s normal to forget key steps. Programming efficiency builds incrementally—there’s no shortcut. Active Learning Learning to code is like learning a foreign language: practicing by “speaking” (i.e. actually writing and running code) is far more effective than just reading. Do not limit yourself to reading code in a book—actively write and test it. One advantage of programming is that mistakes stay private to you and your computer. Embrace that safe space to experiment. Fortunately, we don’t have to embarrass ourselves when we try the wrong combination of words in programming (the only people who will know your silliness is you and ChatGPT). Appropriate Learning Don’t get stuck in tutorial hell. It easy to get caught up in tutorials and never actually build anything. I recall buying a few courses on Udemy for R programming, because it just wasn’t clicking. The example data that was provided were basketball statistics sports data, and compounding savings finance data. It was impossible for me to translate those tutorials into what I was trying to achieve. Avoid Tutorial Overload Be cautious about endless tutorials that don’t match your research needs. If example data is far removed from your work (like sports or finance data), you might struggle to see how it helps with, say, flow cytometry. Seek practice with examples relevant to your actual data and objectives. Handling data - be specific! Unlike with Excel or Prism, you won’t be double-clicking cells. If you want to change the value in the 3rd column and 5th row, you’ll need an explicit instruction like: my_data[5,3] &lt;- new_value … and so you’ll need to learn quickly to be specific. Eventually, you’ll learn to automate repetitive tasks, such as finding all rows containing “CD45RA” or “CD4.” Before long, you’ll understand that formatting data consistently—e.g. avoiding spaces in column names—saves you from constant reformatting or code breakage. An accidental space in something like Sample Number becomes Sample.Number, and your existing scripts may fail. Before using R, I spent countless hours copy/pasting to get data formatted for Prism. If you’ve had that frustration, learning consistent data formatting for R can prevent a lot of manual effort. I hope that as you navigate through these lessons, you try to amend your own spreadsheets so that your data becomes an R-friendly format. Directories Forget double-clicking in File explorer &amp; Finder! When you open RStudio, you’re essentially using a text editor (with syntax highlighting) that executes code. If R is pointed to the wrong folder, you may accidentally open or overwrite the wrong files. Could you imagine thinking that you’re editing row 5 and column 3 of your raw data, and not realising that you’re editing the tissue log! Directories are the most common errors! For both beginner and experienced users! Set your directory at the beginning of each script/session! For these sessions, I’ve created a folder on my desktop (mac) called analysis_user_group. We want to tell R where to look for files/folders and where to save our data/plots. setwd(&quot;~/Desktop/analysis_user_group&quot;) I can check my working directory using getwd() [1] \"/Users/thomasoneil/Desktop/analysis_user_group\" You can verify which files are present by using list.files() Note on “.” and “..” In a directory path, . means “this directory” and .. means “the parent directory.” For instance, list.files(“..”) will list files in the folder above your current one. Reproducibility and automation Tracking every minor change in a spreadsheet—removing rows, shifting columns, or redoing analyses in FlowJo—can be tedious. By contrast, each line of code in R is an explicit instruction, and you can save or version your script to see exactly what was done. Any time you need to adjust or repeat the analysis, you can simply run the script again. Even better, you can automate many analyses. Once you have a working script, just change the folder path (and data, if needed), and you can generate a fresh report for new experiments. Combine multiple R scripts into a Markdown book to share with collaborators or keep for your records. This alone makes programming worthwhile: reproducibility is seamless, and the clarity you gain over your data transformations is invaluable. Next Chapter → "],["chapter-1-getting-started-in-r-and-rstudio.html", "Chapter 1: Getting Started in R and RStudio R as a programming language Installing R and RStudio Navigating RStudio Projects Using R Hello World Exercise: Write your first second script Next Chapter", " Chapter 1: Getting Started in R and RStudio Your first steps… Goals: Set up R and RStudio, and get familiar with the interface.   • Understand what a programming language is.   • Know the difference between R, RStudio and python.   • Install R and RStudio.   • Exploring the interface – Console, Environment, Scripts.   • Installing and loading packages.   • Start your first project. By the end of this chapter, you’ll have installed R and RStudio, know how to navigate the RStudio UI and will know how to get started on a new project. To start with… Create a folder that you’ll work out of for this tutorial. For example, I have a folder analysis-user-group on my Desktop. Read time: 30 Minutes R as a programming language Simply: A programming language is a way to communicate with a computer. There are many languages, each with their own advantages and limitations. Some, such as SQL are used in database management, and others like R and python are used for analytic programming. R is designed specifically for statistical computing, data analysis and visualisation, and is considered one of the more user-friendly languages. Python is more of a general-purpose language used in data science, but also for web development, machine learning, and more. The language itself needs an interface for you to communicate with the computer. You can run R in Terminal (Mac) or Command Prompt (Windows) if you wanted to. You could store your scripts in Word and then copy and paste the lines into the commandline window. By now, you’ve heard of and seen RStudio. RStudio is what’s called an Integrated Development Environment (IDE) and makes working with R easier by organizing scripts, plots, and files. Installing R and RStudio Install R first. Go to CRAN, download the latest version of R and follow the prompts to install on your computer. You don’t need to do anything else with the R application! Next install RStudio. Go to the download page and follow the prompts to install on your computer. Once installed, open RStudio—it should automatically connect to your R installation. Navigating RStudio When you first open RStudio, you’ll see four main panels: Console (Bottom Left): This is essentially R. This is where you run the code. Environment (Top Right): Keeps track of your variables and data. Files/Plots/Packages (Bottom Right): Displays file directories, plots, help pages, and packages. Script Editor (Top Left): This is simply a text editor. This is where you would write and save your code. We will now start using R. You will be able to copy and paste code either directly into the console or into a new script, which you can save for later! Projects Projects in RStudio help organize your files and workflows. Create a Project: Go to File &gt; New Project. Select New Directory or link to an Existing Directory. Name your project and choose a folder location. Click Create Project. This sets up a workspace, saving all files and settings in one place. Use projects to keep analyses organized and reproducible. Using R It might feel like we’re moving too quickly through some of this. Don’t worry! The next few chapters will go into variables, data structures, functions and so on in more details using mock data. chunk: I’ll refer to the blocks of code you see throughout these lessons as a chunk. function: A function is a set of statements that are run at the same time. argument: An argument is a value/variable used in a function. package: A package is simply a collection of functions. R as a programming language is a set of basic functions. Some of these include: Arithmetic Code # sums 1+1 ## [1] 2 Code # subtraction 3-1 ## [1] 2 Code # multiplication 2*2 ## [1] 4 Code # division 40/pi ## [1] 12.7324 Code # exponents 2^2 ## [1] 4 Print and Paste Code # print a sentence print(&quot;This is a sentence.&quot;) ## [1] &quot;This is a sentence.&quot; Code # print two things &#39;pasted&#39; together print(paste(&quot;This is pi:&quot;, pi)) ## [1] &quot;This is pi: 3.14159265358979&quot; print() and paste() are examples of base R functions. DoHeatmap() and NormalizeData() are examples of functions that are derived from the Seurat package, used for scRNA seq analysis We might combine a series of these base R functions to create unique and specific output. For example, lets say I was constantly calculating cell percentages based off of cell numbers, and want to output a sentence summary. I might write it like this each time: Code num_cd45 = 45000 # number of CD45+ cells num_cd3 = 22000 # number of CD3+ cells per_cd3 = num_cd3/num_cd45 # calculate the fraction per_cd3 = per_cd3*100 # multiply by 100 to get a percentage per_cd3 = round(per_cd3, digits=2) # round the data off - here is an example of an argument - I can specify how many digits I want to include paste(&quot;There are &quot;, num_cd45, &quot; CD45+ cells and &quot;, num_cd3, &quot; CD3+ cells (&quot;, per_cd3, &quot;%)&quot;, sep = &quot;&quot;) # output the statement ## [1] &quot;There are 45000 CD45+ cells and 22000 CD3+ cells (48.89%)&quot; I would have several samples to calculate these for, and I don’t want to repeat these lines of code n times! We could write this into our own function (I will demonstrate how to do this in a future lesson) or hopefully someone has already done this. Lets pretend… …someone has already solved this issue. They’ve written the functions that we want and published them as package called simple_math. We would install this package and have access to the functions. Code # install the package install.packages(&quot;simple_math&quot;) A package only needs to installed once! You can manually search for your packages in RStudio in the Packages tab on the right. Or simply try to load it using… Code # load the package library(simple_math) You will need to load packages into your R sessions every time you restart R Now that simple_math is loaded into our session, we could use the functions within the package. This is what the function might look like: Code calculate_percent( parent = &quot;CD45&quot;, parent_num = 45000, subset = &quot;CD3&quot;, subset_num = 22000, digits = 1 ) ## [1] &quot;There are 45000 CD45+ cells and 22000 CD3+ cells (48.9%)&quot; This is a super reductionist explanation of functions and packages. Not only do functions and packages use base R functions, they themselves require functions from other packages. E.g. the Seurat package uses ggplot functions to generate graphs. As you perform more and more complex analyses, you will be installing and loading more and more packages necessary. There are some very common packages that you’ll likely use a lot such as: ggplot2 for visualisation dplyr for data manipulation Seurat for single cell analysis BiocManager for installing additonal bioinformatic packages … etc, etc Commenting code: You might have noticed that within the R chunks. Comments are ways of adding details and descriptions to your otherwise dry code. They are prefaced by a # The can be used in two ways: On their own line     # this is a comment     1+1     [1] 2 After code     1+1 # this will add 1 to 1     [1] 2 It is incredibly useful to comment your code. Some examples may be: You’ve written a script or custom function and want to remember what each line does. You’ve written a script or custom function and want to inform others what each line does. You’ve changed a script, but want to keep a copy of the older version - you could comment out each line. etc etc Hello World It’s customary that your first script is helloworld.R. So! Open a new script and save it in your analysis-user-group folder as helloworld.R. In this script add the line: Code print(&quot;Hello World&quot;) Click on this line in your script editor and press: Mac: Command-Enter Windows: Control-Enter This sends the line you’re on to the console and runs it. You’ll get the output [1] &quot;Hello World&quot; Congratulations. You wrote your first program.You’re a genius.Well done.You’re on your way to becoming a superstar programmer. Exercise: Write your first second script Practice:   Create an R script.          Send a line to the console. (See Hello World above)          Set your directory.          Install the ggplot2 package.          Load in sthe ggplot2 packages.          Download the dataset used for these tutorials into my directory.          Load in the dataset.          Inspect the data.          Create a simple plot of the data.          Save the plot in your directory. The data: In this exercise, and throughout these tutorials, we’ll be using flow cytometry data I synthesised representing mock cell frequencies and expressions of T cells dervied from human tissues (n=60). The data dictionary below provides a description for each column Data Dictionary: Column Description date Date of acquisition experiment Experiment number donor Donor Number age Age of patient tissue Tissue type: abdomen, labia, vagina layer Tissue layer: epithelium, underlying mucosa group Summarised sample group (e.g. A_E = abdomen epithelium) CD3 CD3+ cells CD8 CD8+ cells CD4 CD4+ cells HLADR CD4+HLADR+ cells CCR5 CD4+CCR5+ cells HLADR_MFI gMFI of HLADR on CD4+ cells CCR5_MFI gMFI of CCR5 on CD4+ cells CD28 CD4+CD28+ cells gMFI:geometric mean fluorescent intensity. Exercise: Write a script using the following instructions (run the lines as you write to see if its working for you) Open a new R script and save it to a folder of your choice. At the top of each of your scripts, you might want to add some comments about what the script is for. Set your working directory using setwd(). One way to quickly find the directory is to copy the folder and paste it into the script itself. Install ggplot2 Load the ggplot2 package Download the example data using: Code download.file(url=&quot;https://raw.githubusercontent.com/DrThomasOneil/analysis-user-group/refs/heads/main/docs/r-tutorial/assets/synthetic_data.csv&quot;, destfile=&quot;synthetic_data.csv&quot;) Don’t see the file? If you have set your directory properly, you will see a new file in your folder called synthetic_data.csv. Load the data into R using data &lt;- read.csv(\"synthetic_data,csv\") Inspect the data colnames() will show you what columns are present dim(data) will show you the dimensions of the data as rows x columns. head(data) will show you the first 6 rows of the data. Conversely, you could use tail(). summary(data) will give you detailed output of the data. Assign to a variable plot a graph of % CD4+ T cells in each group using the ggplot() function. Here you can copy and paste my code, as we don’t cover ggplot until Chapter 5 In Chapter 5 &amp; 6, we will learn how to use ggplot and how to make publication-worthy graphs Code plot = ggplot(data, aes(x=group, y=100*(CD4/CD3), color=tissue))+geom_boxplot() Output the plot by writing plot in the console. Save the plot to your directory using ggsave(). Use ?ggsave in the console to bring up the help menu for this function! Here you will find descriptions of the function, the arguments you can use and examples of it’s use. Solution Here is one possible solution. Did you comment your code? Code #* This is my first script #* I will set my directory, install my first package, load it in, and save a variable to my directory #* 20250107 # set your directory setwd(&quot;~/Desktop/analysis-user-group&quot;) #THIS WONT WORK FOR YOU - YOU&#39;LL NEED TO SET YOUR OWN DIRECTORY # uncomment and install the package once # install.packages(&quot;ggplot2&quot;) # load the package library(ggplot2) # download the example data download.file(url=&quot;https://raw.githubusercontent.com/DrThomasOneil/analysis-user-group/refs/heads/main/docs/r-tutorial/assets/synthetic_data.csv&quot;, destfile = &quot;synthetic_data.csv&quot;) # read in synthetic data data &lt;- read.csv(&quot;synthetic_data.csv&quot;) # inspect the data colnames(data) dim(data) head(data) summary(data) # create a simple plot of percentage of CD4+ cells per group plot &lt;- ggplot(data, aes(x=group, y=100*(CD4/CD3), color=tissue))+geom_boxplot() # output the plot plot # save plot ggsave(&quot;myfirstplot.png&quot;,plot = plot) You may have seen me use = and &lt;- interchangeably. That’s because they are. Next Chapter Congratulations! You’ve completed Chapter 1. You now have R and RStudio installed, have installed a package and started to write scripts. In the next two chapters, I will use this data to explain more about the fundamentals of R. Next Chapter → "],["chapter-2-data-types-and-structures.html", "Chapter 2: Data Types and Structures Data Types Data Structures Importing and saving files in R", " Chapter 2: Data Types and Structures Goals: Learn about data types and structures in R.   • Basic data types: numeric, character, logical.   • Data structures: vectors, matrices, data frames, lists.   • Assessing and querying data types and structures.   • Importing data (RDS, Excel, CSV files). Read time: 15 Minutes Data Types There are a few data types you should know: character: In R, characters or strings are letters, words, sentences, numbers, symbols… They’re defined using quotation marks. numeric: Data can be stored as a number. R recognises numbers without the quotation marks logical: TRUE / FALSE / T / F / 1 / 0. Logicals are an important data type that you’ll notice along the way. Some functions or operations require data to the correct data type. For example, math can’t be performed on a character Code # character char = &quot;Hello World&quot; typeof(char) ## [1] &quot;character&quot; Code # numeric num = &quot;1&quot; typeof(num) # 1 is in quotes - so classified as a char ## [1] &quot;character&quot; Code num = 1 typeof(num) # without the quotes ## [1] &quot;double&quot; Code # logical log = TRUE typeof(log) ## [1] &quot;logical&quot; To demonstrate a logical, a good example of their use is to check a condition and run a script. I’ll use if here, which we cover in the next chapter. Examples: Code # TRUE run_script = TRUE if(run_script) { print(paste0(&quot;run_script is &quot;, run_script)) } ## [1] &quot;run_script is TRUE&quot; Code run_script = T if(run_script) { print(paste0(&quot;run_script is &quot;, run_script)) } ## [1] &quot;run_script is TRUE&quot; Code run_script = 1 if(run_script) { print(paste0(&quot;run_script is &quot;, run_script)) } ## [1] &quot;run_script is 1&quot; Code # FALSE run_script = FALSE if(run_script) { print(paste0(&quot;run_script is &quot;, run_script)) } run_script = F if(run_script) { print(paste0(&quot;run_script is &quot;, run_script)) } run_script = 0 if(run_script) { print(paste0(&quot;run_script is &quot;, run_script)) } Above, we set the variables deliberately to demonstrate how they can be used. However, they don’t need to be deliberately set to be useful. Code a = 3 typeof(a) ## [1] &quot;double&quot; Code is.numeric(a) ## [1] TRUE Code typeof(is.numeric(a)) ## [1] &quot;logical&quot; Code if(is.numeric(a)){ print(paste0(&quot;The variable a (&quot;, a,&quot;) is numeric.&quot;)) } ## [1] &quot;The variable a (3) is numeric.&quot; Code a=&quot;3&quot; if(is.numeric(a)){ print(paste0(&quot;The variable a (&quot;, a,&quot;) is numeric. Continuing the analysis.&quot;)) } else { print(paste0(&quot;The variable a (&quot;, a,&quot;) is &quot;, typeof(a), &quot;. Not continuing the analysis.&quot;)) } ## [1] &quot;The variable a (3) is character. Not continuing the analysis.&quot; Data Structures Data types can be organised into structures. These are: vectors: A vector is a collection of data, such as c(1990, 1990, 1991, 1989) or c(“Rou”, “Chris”, “Rory”, “Rob”) matrix: A matrix is data organised into rows and columns. Data in a matrix is only of one data type. data frames: A data frame is similar to a matrix, but can contain different data types. lists: A list is dynamic and can hold all different types of data structures and data types. Code yr &lt;- c(1990, 1990, 1991, 1989) name &lt;- c(&quot;Rou&quot;, &quot;Chris&quot;, &quot;Rory&quot;, &quot;Rob&quot;) rating &lt;- c(4,4,4,5) df &lt;- data.frame(year = yr, names = name, ratings = rating) df Code dim(df) ## [1] 4 3 We can see this dataframe is 4 rows tall and 3 columns wide. We can access information in a dataframe using: df[row, col] Code df[1,1] ## [1] 1990 With data frames, we can also use $ to query a specific column. Code df$names ## [1] &quot;Rou&quot; &quot;Chris&quot; &quot;Rory&quot; &quot;Rob&quot; More examples: Code # show all rows in certain columns df[,1] ## [1] 1990 1990 1991 1989 Code df[,&quot;names&quot;] ## [1] &quot;Rou&quot; &quot;Chris&quot; &quot;Rory&quot; &quot;Rob&quot; Code # show all columns in one row df[1,] # show select columns by providing a vector of specific indices df[,c(1,3)] # provide a range of indices quickly using colon between numbers. e.g. 1 to 2 df[,c(1:2)] # instead of using indices to pull information, we can use logic df[c(T,T,F,T),] We can do a lot with a data frame if we combine everything we know about data types and structures Code # store a row or column as a new object patient_1 = df[1,] patient_1 # return a logical vector based on a query df$names == &quot;Rou&quot; ## [1] TRUE FALSE FALSE FALSE Code # and add this to a new column df$is_rou &lt;- df$names == &quot;Rou&quot; df # With a large dataframe, we might not know the specific indices we want to see or store, # so we could cut a dataframe or pull information based on certain logic df[df$names==&quot;Rou&quot;,] df[df$ratings&lt;5,] When working with enormous data structures, like single cell sequencing or proteomics data, knowing how to query your data frame or matrix will be very useful! Finally, we can make a list out of all of these different data types and structures, Code list &lt;- list(&quot;number&quot; = 1, &quot;string&quot; = &quot;string&quot;, &quot;logical&quot; = TRUE, &quot;vector&quot; = name, &quot;dataframe&quot; = df) list ## $number ## [1] 1 ## ## $string ## [1] &quot;string&quot; ## ## $logical ## [1] TRUE ## ## $vector ## [1] &quot;Rou&quot; &quot;Chris&quot; &quot;Rory&quot; &quot;Rob&quot; ## ## $dataframe ## year names ratings is_rou ## 1 1990 Rou 4 TRUE ## 2 1990 Chris 4 FALSE ## 3 1991 Rory 4 FALSE ## 4 1989 Rob 5 FALSE Ways to query your list Code list[[1]] ## [1] 1 Code list[[&quot;vector&quot;]] ## [1] &quot;Rou&quot; &quot;Chris&quot; &quot;Rory&quot; &quot;Rob&quot; Code list$string ## [1] &quot;string&quot; Importing and saving files in R Most file types can be read into R. If you’re not working with xlsx or csv, you might be working with tsv, txt, h5ad, or xml. Some are easier than others, and you’ll learn them as you go. Another file type is RDS which is R Data Serialization which is the easiest and most efficient way to read and write data once you’ve got it in R. RDS is more efficient than csv because saving and writing a csv is not as standard as you think. For example, a column name might change, rownames don’t stick unless directly specified when reading it back in. On the other hand, saveRDS() &amp; readRDS() requires no extra information. Your data will be identical when read back in. Most commonly, you’ll use data &lt;- read.csv() or data &lt;- readRDS(). To read in excel files, you’ll need to install a package (try the packages xlsx for read.xlsx(), or readxl for read_excel() - I can’t recall why, but sometimes one of these won’t work). Throughout these tutorials, you’ll use read.csv() to read in the example data we downloaded in Chapter 1. We’ll then finish each tutorial with saveRDS() and begin the next tutorial with readRDS(). This is a nice and organised way that you may use yourself when analysing data. This is effectively having stop and start points. Next chapter → "],["chapter-3-basic-programming.html", "Chapter 3: Basic Programming Assigning variables Conditional statements Loops Writing a function", " Chapter 3: Basic Programming Goals: Understand programming logic for automating tasks.   • Variables and assignments.   • Conditional statements (if, else).   • Loops (for, while).   • Writing functions. Read time: 10 Minutes Assigning variables We’ve already demonstrated variables and assignment. What we mean by this is a &lt;- 3, where we assign the variable 3 to a. We’ve also already assigned dataframes and lists to objects too. In short, we do this to store and use information a lot more efficiently. You can store anything you might want to use later, but remember that you will continuously take up more and more space with every object and variable you save. Code setwd(&quot;directory&quot;) Code data &lt;- read.csv(&quot;~/Desktop/analysis-user-group/synthetic_data.csv&quot;) Conditional statements Conditional statements let you break up and execute your code based on different conditions, such as if and else. Code data$predominant_subset &lt;- ifelse( data$CD8&gt;data$CD4, #Condition &quot;CD8&quot;, # if condition is met, this is the outcome &quot;CD4&quot; # ELSE this is the outcome. ) # get a quick summary of these results table(data$predominant_subset, data$layer, data$tissue) ## , , = Abdomen ## ## ## Epithelium Underlying ## CD4 5 0 ## CD8 19 24 ## ## , , = Labia ## ## ## Epithelium Underlying ## CD4 0 20 ## CD8 20 0 ## ## , , = Vagina ## ## ## Epithelium Underlying ## CD4 0 16 ## CD8 16 0 You can see that there are several variations of the Abdomen tissue type, likely as a result of human input error when adding data to the csv. We’ll fix these below using loops. Loops With loops, we can iterate functions over a dataset, such as number of rows and number of columns, or number of samples in a folder. There are two types: for which will iterate a specified number of times. E.g. for indexes in 1 through 100, print which index you’re up to written as for(index in 1:100){print(index)} while which will iterate indefinitely until a condition is not met. E.g. while the index is less than or equal to 100, print the index written as Code index=1 while(index &lt;=100){ print(index) index=index+1 } Here is an example of using a loop and a check which indexes are coming up with differences. Code n_vagina = 0 n_labia = 0 n_abdo = 0 for(index in 1:nrow(data)){ #loop from 1 through nrows in data (1,2,3...121,120) and assign this value to &#39;index&#39; if(data$tissue[index] == &quot;Abdomen&quot;){ #check if the string at row[index] in the &#39;tissue&#39; column matches abdomen. n_abdo = n_abdo+1 #If so, add 1 to the variable. } else if(data$tissue[index] == &quot;Labia&quot;){ # repeat n_labia=n_labia+1 } else if(data$tissue[index] == &quot;Vagina&quot;){ n_vagina=n_vagina+1 } else { print(paste(data$tissue[index], &quot;at index&quot;,index,&quot;does not match Abdomen, Labia or Vagina.&quot;)) # print a statement if the condition is met. } } print(paste0(n_vagina, &quot; vagina samples. &quot;, n_labia, &quot; labia samples. &quot;, n_abdo, &quot; abdomen samples. (Total: &quot;,n_abdo+n_labia+n_vagina,&quot;)&quot; )) ## [1] &quot;32 vagina samples. 40 labia samples. 48 abdomen samples. (Total: 120)&quot; We know that there are 120 samples, but here it’s printing 117, because there are 3 instances where Abdomen are not found (written abdomen, or Abdo). This will be a headache when generate plots or statistics. We could change these manutally, but I’ll write a function below which finds those errors and lets the user change the value. Writing a function Functions can be quite simple to write and easy to implement for simple repetitive tasks. For example, with single cell RNA analysis with Seurat, if you’re testing different variables, having the workflow summarized in one function will make your workflow tidier. Here we’re just going to write the checker above into a function with some extra user-input functionality. Code sample_counter &lt;- function(data){ n_vagina = 0 n_labia = 0 n_abdo = 0 for(index in 1:nrow(data)){ #loop from 1 through nrows in data (1,2,3...121,120) and assign this value to &#39;index&#39; if(data$tissue[index] == &quot;Abdomen&quot;){ #check if the string at row[index] in the &#39;tissue&#39; column matches abdomen. n_abdo = n_abdo+1 #If so, add 1 to the variable. } else if(data$tissue[index] == &quot;Labia&quot;){ n_labia=n_labia+1 } else if(data$tissue[index] == &quot;Vagina&quot;){ n_vagina=n_vagina+1 } else { print(paste(data$tissue[index], &quot;at index&quot;,index,&quot;does not match Abdomen, Labia or Vagina.&quot;)) checkval=0 while(checkval==0){ input = readline(&quot;Choose correct value: [1] Abdomen, [2] Labia, [3] Vagina. &quot;) if(input %in% c(1:3)) { if(input==1){ n_abdo = n_abdo+1 data$tissue[index] = &quot;Abdomen&quot; } else if(input==2) { n_labia=n_labia+1 data$tissue[index] = &quot;Labia&quot; } else if(input==3) { n_vagina=n_vagina+1 data$tissue[index] = &quot;Vagina&quot; } checkval = 1 #exit the while loop } else { cat(&quot;\\nIncorrect input. Try again.\\n&quot;) } } } } print(paste0(n_vagina, &quot; vagina samples. &quot;, n_labia, &quot; labia samples. &quot;, n_abdo, &quot; abdomen samples. (Total: &quot;,n_abdo+n_labia+n_vagina,&quot;)&quot; )) return(data) } Code data &lt;- sample_counter(data) 1 1 1 write.csv(data, &quot;~/Desktop/analysis-user-group/synthetic_data.csv&quot;) Throughout your analysis, you’ll find more relevant for loops, while loops and functions that make you more efficient at programming. Next chapter → "],["chapter-4-data-manipulation-with-tidyverse.html", "Chapter 4: Data Manipulation with tidyverse Why use tidyverse Filtering rows and columns Adding a column using mutate() group_by() and summarize() Pivot", " Chapter 4: Data Manipulation with tidyverse Goals: Introduce tidyverse for filtering, mutating, summarizing and pivoting data.   • Filtering rows (filter()), selecting columns (select()).   • Adding new columns (mutate()).   • Grouping and summarizing (group_by() + summarize()).   • Pivot longer and Pivot wider Read time: 10 Minutes Why use tidyverse If you wanted to just analyse a portion of your data, you could just subset the data frame. Code abdo &lt;- data[data$tissue == &quot;Abdomen&quot;,] # select only the rows where tissue contains Abdomen mean(abdo$CCR5_MFI) ## [1] 4729.088 Code abdo_epi &lt;- abdo[abdo$layer == &quot;Epithelium&quot;,] abdo_um &lt;- abdo[abdo$layer == &quot;Underlying&quot;,] mean(abdo_epi$CCR5_MFI) ## [1] 5462.761 Code mean(abdo_um$CCR5_MFI) ## [1] 3995.416 However, you might have already noticed that your environment is filling up with objects and variables that we keep assigning. With more complicated data this can get pretty annoying. We can remove things from the environment using rm(abdo, abdo_epi, abdo_um). We could instead write long conditionals within the square brackets. Code mean(data[data$tissue == &quot;Abdomen&quot; &amp; data$layer == &quot;Epithelium&quot;, &quot;CCR5_MFI&quot;]) ## [1] 5462.761 Code mean(data[data$tissue == &quot;Abdomen&quot; &amp; data$layer == &quot;Underlying&quot;, &quot;CCR5_MFI&quot;]) ## [1] 3995.416 However, you’ll find that this gets very long and confusing and annoying as you incorporate these into other functions, like ggplot. This is where dplyr becomes advantageous. dplyr allows us to manipulate an object without changing it permanently, using very efficient functions and a concept called pipes. dplyr is a package within the tidyverse ecosystem, which contains dplyr, tidyr, ggplot2, tibble, stringr, and others. So, we can install and load tidyverse for this chapter. Filtering rows and columns Pipes (%&gt;%) are an important concept and effectively stand for “using this”. From the example above, we could use dplyr instead, without assigning any new vairables, in a nice and tidy and follwable layout. When spoken, it might read like… Code data %&gt;% # using this object, I want to... filter(tissue == &quot;Abdomen&quot;) %&gt;% # then &quot;using this&quot; new filtered object filter(layer == &quot;Epithelium&quot;) %&gt;% select(CCR5_MFI) %&gt;% # using this object, select CCR5_MFI column unlist() %&gt;% # unlist to make it a vector mean() # and get the mean ## [1] 5462.761 Now, this seems like a lot for determining one value, but we’ll see what group_by() and summarize() do shortly, which demonstrate why you might want to learn dplyr asap. Adding a column using mutate() Similarly, in previous chapters, we have added columns to the data for ease of use. For example: Code # assign a new column data$percent_CD4 &lt;- 100*data$CD4/data$CD3 # then use dplyr to determine the mean value of Abdomen Epithelium data %&gt;% filter(tissue == &quot;Abdomen&quot;) %&gt;% filter(layer == &quot;Epithelium&quot;) %&gt;% select(percent_CD4) %&gt;% unlist() %&gt;% mean() ## [1] 43.09003 However, there might be hundreds of extra columns I want to make. And that means making 100 unique and descriptive column names, that then just gets more and more confusing as you add to the data. So, we can use mutate() instead, so that we don’t have to alter our original data. Code data %&gt;% mutate(percent_CD4 = 100*CD4/CD3)%&gt;% # Add a new column filter(tissue == &quot;Abdomen&quot;) %&gt;% filter(layer == &quot;Epithelium&quot;) %&gt;% select(percent_CD4) %&gt;% unlist() %&gt;% mean() %&gt;% round(2) ## [1] 43.09 group_by() and summarize() Here we’ve been writing 8 lines of code to get the mean values of one tissue type, which is useful if you wanted to do something with that exact single value. Alternatively, we can also use group_by() or summarize() to get values across multiple variables. Code data %&gt;% mutate(percent_CD4 = 100*CD4/CD3) %&gt;% group_by(tissue, layer) %&gt;% # almost like &#39;treat the data like n-data frames per combinations of tissue and layer summarize(mean_percent_CD4 = mean(percent_CD4)) # summarise in a new table ## `summarise()` has grouped output by &#39;tissue&#39;. You can override using the `.groups` argument. Pivot Packages and functions, e.g. ggplot, will sometimes require that data is organised in the correct way. pivot_longer() and pivot_wider() can be effective tools for rearranging your data to suit. Here we’ll just use a short subset of the data to easily visualise what is happening. Code data2 &lt;-data[c(1:10,25:34, 41:50),colnames(data) %in% c(&quot;donor&quot;, &quot;tissue&quot;, &quot;layer&quot;, &#39;group&#39;, &quot;CD3&quot;, &quot;CD4&quot;, &quot;CD8&quot;)] Currently, the data is in what we might consider wide format. We have one row per tissue layer and columns for our CD3, CD4, CD8 cell counts. We’ll start by mutating extra columns to get the CD4 and Cd8 percentages and then making it long, so that we get one column called “percent” with CD4 and CD8 in a different single column called “subset”. This is a format then compatible with ggplot. Code data2 %&gt;% mutate(percent_CD4 = 100*CD4/CD3, percent_CD8 = 100*CD8/CD3) %&gt;% pivot_longer(cols = c(percent_CD4, percent_CD8), #which columns to choose for elongating names_to = &quot;subset&quot;, # name of new column containing names values_to = &quot;percent&quot;) %&gt;% # name of new column containing values print() You’ll notice we have duplicate entries for CD3, CD8 and CD4, but our column subset has alternating percent_CD4/CD8 and the value for that donor is in the percent column. This can now be used in a boxlpot in ggplot. Code data2 %&gt;% mutate(percent_CD4 = 100*CD4/CD3, percent_CD8 = 100*CD8/CD3) %&gt;% pivot_longer(cols = c(percent_CD4, percent_CD8), names_to = &quot;subset&quot;, values_to = &quot;percent&quot;) %&gt;% ggplot(aes(x=group, y=percent, fill=subset)) + geom_boxplot(outliers=F)+theme_classic() Imaging having a dataframe tens of thousands long, and you were to pivot longer and then store this data. You can imagine how inefficient your analysis workflow would become in such circumstances. Ok. Lets say that we wanted to see if there was a correlation between the percent of CD4+ T cells in epithelium versus underlying mucosa. To do this, we calculate the percent of CD4, but we need an x and y vector to give to ggplot. Currently, the data object looks like a long version of what we want. So we can pivot wider to make our graph. Code data2 %&gt;% mutate(percent_CD4 = 100*CD4/CD3) %&gt;% select(-c(group, CD3,CD4,CD8))%&gt;% # using a - with select lets use remove, instead of select a given column. group_by(tissue)%&gt;% pivot_wider(names_from = layer, values_from = percent_CD4) %&gt;% ggplot(aes(x=Epithelium, y=Underlying, color=tissue))+ geom_point()+ stat_ellipse()+ theme_classic() Hopefully it is clear why tidyverse is a useful tool. The next two chapters will continue to build your skills up to generating a range of different figures using ggplot. Next chapter → "],["chapter-5-data-visualisation-with-ggplot2.html", "Chapter 5: Data Visualisation with ggplot2 Basics of ggplot2 Summary", " Chapter 5: Data Visualisation with ggplot2 Goals: Create and customize visualizations using ggplot2.   • Basics of ggplot2   • Make a scatterplot, boxplot and column graph   • Customise labels, themes, and colors. R is a powerful tool for visualisation. Base R has its own graphing functions, but it’s. honestly a bit too simple and ugly for publication. ggplot2 is perhaps the most commonly used package. A more detailed resource can be found here. ggplot will be split across two chapters. The first will be the fundamentals for making figures, and the next chapter will have notes on detailed customisations. Read time: 20 Minutes Basics of ggplot2 ggplot2 is simply an expansive toolbox of graphics and functions that you may combine in infinitely unique ways to create figures for your specific needs and liking. The design of a ggplot graphic is that it is built in layers: Start with the raw input data: which object will you use? Which columns will be on the x, y, will be grouped, will be used for colours? Next, define how the data will be plotted - scatterplot, violin, column, boxplot, heatmap, density etc. Add layers. Add titles? Add a caption? Change the colour palette? Change the theme? data: The information you want to visualise. layer collection of geometic elements and statistical transformations aesthetic attributes: color, shape, size geometric objects: points, lines, bars (geom for short) statistical transformation: summary of the data (e.g. binning in a histogram) (stat for short) mapping: description of how the variables are mapped to aesthetic attributes facet: how to break up and display subsets of data theme: the finer points of display, like font size and background colour Example Question What is the relationship between CCR5 and HLA-DR percentages in human tissues? Scatterplot Using this example we’ll look at how the percentage of CCR5 and HLA-DR are correlated in this dataset. Code setwd(&quot;~/Desktop/analysis-user-group/&quot;) data &lt;- read.csv(&quot;~/Desktop/analysis-user-group/synthetic_data.csv&quot;) Code data %&gt;% mutate(percent_CCR5 = 100*CCR5/CD4, percent_HLADR = 100*HLADR/CD4) %&gt;% ggplot(aes(x = percent_CCR5, y = percent_HLADR))+ geom_point() You don’t need to use pipes for ggplot: This will also work: Code data &lt;- data %&gt;% mutate(percent_CCR5 = 100*CCR5/CD4, percent_HLADR = 100*HLADR/CD4) ggplot(data, aes(x = percent_CCR5, y = percent_HLADR))+ geom_point() Lets start with a few aesthetic things. I’ll build these sequentially and point out what is changing each time. Change the titles and axes: Code data %&gt;% mutate(percent_CCR5 = 100*CCR5/CD4, percent_HLADR = 100*HLADR/CD4) %&gt;% ggplot(aes(x = percent_CCR5, y = percent_HLADR))+ geom_point() + ggtitle(&quot;Add a title using ggtitle()&quot;) Code data %&gt;% mutate(percent_CCR5 = 100*CCR5/CD4, percent_HLADR = 100*HLADR/CD4) %&gt;% ggplot(aes(x = percent_CCR5, y = percent_HLADR))+ geom_point() + ggtitle(&quot;Change the axes with xlab() and ylab()&quot;)+ xlab(&quot;CCR5 %&quot;)+ylab(&quot;HLA-DR %&quot;) Code data %&gt;% mutate(percent_CCR5 = 100*CCR5/CD4, percent_HLADR = 100*HLADR/CD4) %&gt;% ggplot(aes(x = percent_CCR5, y = percent_HLADR))+ geom_point() + labs(title = &quot;Or use `labs()` to change all at once&quot;, x= &quot;CCR5 %&quot;, y= &quot;HLA-DR %&quot;) Change the overall layout: Use theme_ to test out different styles. Here are my three most commonly used. Code data %&gt;% mutate(percent_CCR5 = 100*CCR5/CD4, percent_HLADR = 100*HLADR/CD4) %&gt;% ggplot(aes(x = percent_CCR5, y = percent_HLADR))+ geom_point() + labs(title = &quot;theme_classic()&quot;, x= &quot;CCR5 %&quot;, y= &quot;HLA-DR %&quot;)+ theme_classic() Code data %&gt;% mutate(percent_CCR5 = 100*CCR5/CD4, percent_HLADR = 100*HLADR/CD4) %&gt;% ggplot(aes(x = percent_CCR5, y = percent_HLADR))+ geom_point() + labs(title = &quot;theme_minimal())&quot;, x= &quot;CCR5 %&quot;, y= &quot;HLA-DR %&quot;)+ theme_minimal() Code data %&gt;% mutate(percent_CCR5 = 100*CCR5/CD4, percent_HLADR = 100*HLADR/CD4) %&gt;% ggplot(aes(x = percent_CCR5, y = percent_HLADR))+ geom_point() + labs(title = &quot;theme_bw()&quot;, x= &quot;CCR5 %&quot;, y= &quot;HLA-DR %&quot;)+ theme_bw() Adjust the aesthetic attributes (categorical): Changing the aesthetic will let us pull more information from the simple black dots Code data %&gt;% mutate(percent_CCR5 = 100*CCR5/CD4, percent_HLADR = 100*HLADR/CD4) %&gt;% ggplot(aes( x = percent_CCR5, y = percent_HLADR, color = tissue ))+ geom_point() + labs(title = &quot;Color by tissue&quot;, x= &quot;CCR5 %&quot;, y= &quot;HLA-DR %&quot;)+ theme_classic() Code data %&gt;% mutate(percent_CCR5 = 100*CCR5/CD4, percent_HLADR = 100*HLADR/CD4) %&gt;% ggplot(aes( x = percent_CCR5, y = percent_HLADR, color = tissue ))+ geom_point() + labs(title = &quot;Color by layer&quot;, x= &quot;CCR5 %&quot;, y= &quot;HLA-DR %&quot;)+ theme_classic() Code data %&gt;% mutate(percent_CCR5 = 100*CCR5/CD4, percent_HLADR = 100*HLADR/CD4) %&gt;% ggplot(aes( x = percent_CCR5, y = percent_HLADR, color = paste0(tissue, &quot;_&quot;, layer) ))+ geom_point() + labs(title = &quot;Color by tissue &amp; layer&quot;, x= &quot;CCR5 %&quot;, y= &quot;HLA-DR %&quot;)+ theme_classic() Code data %&gt;% mutate(percent_CCR5 = 100*CCR5/CD4, percent_HLADR = 100*HLADR/CD4) %&gt;% ggplot(aes( x = percent_CCR5, y = percent_HLADR, color = tissue, shape = layer ))+ geom_point() + labs(title = &quot;Color by tissue &amp; shape by layer&quot;, x= &quot;CCR5 %&quot;, y= &quot;HLA-DR %&quot;)+ theme_classic() Adjust the aesthetic attributes (continuous): We could add a third dimension here. X and Y are the percentage values, but what if we coloured the points by a third continuous value? Code data %&gt;% mutate(percent_CCR5 = 100*CCR5/CD4, percent_HLADR = 100*HLADR/CD4) %&gt;% ggplot(aes( x = percent_CCR5, y = percent_HLADR, color = CCR5_MFI ))+ geom_point() + labs(title = &quot;Color by CCR5 MFI&quot;, x= &quot;CCR5 %&quot;, y= &quot;HLA-DR %&quot;)+ theme_classic() Code data %&gt;% mutate(percent_CCR5 = 100*CCR5/CD4, percent_HLADR = 100*HLADR/CD4) %&gt;% ggplot(aes( x = percent_CCR5, y = percent_HLADR, color = log(CCR5_MFI) ))+ geom_point() + labs(title = &quot;Color by log(CCR5 MFI)&quot;, x= &quot;CCR5 %&quot;, y= &quot;HLA-DR %&quot;)+ theme_classic() Example Question Which tissues are enriched for CCR5? Boxplot Boxplot vs Violin: Code data %&gt;% mutate(percent_CCR5 = 100*CCR5/CD4) %&gt;% ggplot(aes( x = group, y = percent_CCR5 ))+ geom_boxplot() + labs(title = &quot;geom_boxplot()&quot;, y= &quot;CCR5 %&quot;, x= &quot;Tissue x Layer&quot;)+ theme_classic() Code data %&gt;% mutate(percent_CCR5 = 100*CCR5/CD4) %&gt;% ggplot(aes( x = group, y = percent_CCR5 ))+ geom_violin() + labs(title = &quot;geom_violin()&quot;, y= &quot;CCR5 %&quot;, x= &quot;Tissue x Layer&quot;)+ theme_classic() Combining layers - boxplot &amp; points: Code data %&gt;% mutate(percent_CCR5 = 100*CCR5/CD4) %&gt;% ggplot(aes( x = group, y = percent_CCR5 ))+ geom_boxplot() + geom_point()+ labs(title = &quot;geom_boxplot() AND geom_point()&quot;, y= &quot;CCR5 %&quot;, x= &quot;Tissue x Layer&quot;)+ theme_classic() Code data %&gt;% mutate(percent_CCR5 = 100*CCR5/CD4) %&gt;% ggplot(aes( x = group, y = percent_CCR5 ))+ geom_boxplot() + geom_jitter()+ labs(title = &quot;geom_boxplot() AND geom_jitter()&quot;, y= &quot;CCR5 %&quot;, x= &quot;Tissue x Layer&quot;)+ theme_classic() Code # The default jitter is width = 0.5 - we can reduce this data %&gt;% mutate(percent_CCR5 = 100*CCR5/CD4) %&gt;% ggplot(aes( x = group, y = percent_CCR5 ))+ geom_boxplot() + geom_jitter(width=0.1)+ labs(title = &quot;geom_boxplot() AND geom_jitter(width=0.1)&quot;, y= &quot;CCR5 %&quot;, x= &quot;Tissue x Layer&quot;)+ theme_classic() Adjusting the aestheticss: When you’re combining layers, like boxplot and point, you might want to change the aesthetic to each layer individually. So instead of changing the aes at the start, we can add aes inside the geom’s. Code # The default jitter is width = 0.5 - we can reduce this data %&gt;% mutate(percent_CCR5 = 100*CCR5/CD4) %&gt;% ggplot(aes( x = group, y = percent_CCR5 ))+ geom_boxplot(aes(fill = group)) + geom_jitter(width=0.1, aes(color=age))+ labs(title = &quot;geom_boxplot(aes(fill=group))+geom_jitter(aes(color=age))&quot;, y= &quot;CCR5 %&quot;, x= &quot;Tissue x Layer&quot;)+ theme_classic() Example Question What is the ratio of CD4:CD8 per tissue and layer? Column/bar graph Column/bar graphs are useful for summary graphs and/or statistical transformations (such as counts or histograms). Column graph: Code data %&gt;% mutate(ratio = log(CD4/CD8)) %&gt;% group_by(group)%&gt;% summarize(meanratio = mean(ratio))%&gt;% mutate(`Predominant Subset` = ifelse(meanratio&lt;0, &quot;CD8&quot;, &quot;CD4&quot;))%&gt;% ggplot(aes(x=group, y=meanratio, fill=`Predominant Subset`))+ geom_col()+ theme_bw() Example of statistical transformations (Histogram/Bar graph): Code data %&gt;% mutate(percent_CD4 = 100*CD4/CD3, percent_CD8 = 100*CD8/CD3) %&gt;% ggplot(aes(x=percent_CD4))+ geom_histogram()+ theme_bw()+ ggtitle(&quot;Histogram example&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Code # change the bin width to add more resolution data %&gt;% mutate(percent_CD4 = 100*CD4/CD3, percent_CD8 = 100*CD8/CD3) %&gt;% ggplot(aes(x=percent_CD4))+ geom_histogram(binwidth = .5)+ theme_bw()+ ggtitle(&quot;Histogram example&quot;) Code data %&gt;% mutate(predominant = ifelse(CD4&gt;CD8, &quot;CD4&quot;, &quot;CD8&quot;)) %&gt;% ggplot(aes(x=predominant))+ geom_bar()+ theme_bw()+ ggtitle(&quot;Bar graph example: Number of samples that are predominantly CD4 or CD8&quot;) Summary With these simple examples, you should have an idea of how to make and customise ggplots for your data. The next chapter will build upon these, such as changing the theme elements, customising the colours, combining and then saving your plots. Next chapter → "],["chapter-6-data-visualisation-with-ggplot2-2.html", "Chapter 6: Data Visualisation with ggplot2 2 Adjusting theme elements Annotating the plot facet_wrap() and Group Saving plots Some final hints", " Chapter 6: Data Visualisation with ggplot2 2 Goals: Learn additional visualisation techniques.   • Adjusting theme elements   • Annotating the plots   • facet_wrap() and grid_plot()   • Savings plots Read time: 15 Minutes Adjusting theme elements Everything in ggplot can be adjusted. Lets just go through a few of them to show you how its done, and you can explore them as you go. Theme elements: Code data %&gt;% ggplot(aes(CD28, age, color = log(CCR5_MFI))) + geom_point()+ theme_classic()+ theme(axis.text = element_text(size=10), axis.title = element_text(size=12), legend.position = &quot;inside&quot;, legend.justification = c(.99,.99)) Changing the scale: Code data %&gt;% ggplot(aes(CD28, age)) + geom_point()+ theme_bw()+ ylim(0,100) Changing the colours manually: Code data %&gt;% mutate(percent_CCR5 = 100*CCR5/CD4) %&gt;% ggplot(aes( x = group, y = percent_CCR5, fill = group ))+ geom_boxplot(width=0.5) + geom_jitter(width=0.1, alpha=0.2)+ labs( y= &quot;CCR5 %&quot;, x= &quot;Tissue x Layer&quot;)+ scale_fill_manual(values = c(&quot;blue&quot;, &quot;blue4&quot;, &quot;red&quot;, &quot;red4&quot;, &quot;green&quot;, &quot;green4&quot;)) Code theme_classic() ## List of 136 ## $ line :List of 6 ## ..$ colour : chr &quot;black&quot; ## ..$ linewidth : num 0.5 ## ..$ linetype : num 1 ## ..$ lineend : chr &quot;butt&quot; ## ..$ arrow : logi FALSE ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_line&quot; &quot;element&quot; ## $ rect :List of 5 ## ..$ fill : chr &quot;white&quot; ## ..$ colour : chr &quot;black&quot; ## ..$ linewidth : num 0.5 ## ..$ linetype : num 1 ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_rect&quot; &quot;element&quot; ## $ text :List of 11 ## ..$ family : chr &quot;&quot; ## ..$ face : chr &quot;plain&quot; ## ..$ colour : chr &quot;black&quot; ## ..$ size : num 11 ## ..$ hjust : num 0.5 ## ..$ vjust : num 0.5 ## ..$ angle : num 0 ## ..$ lineheight : num 0.9 ## ..$ margin : &#39;margin&#39; num [1:4] 0points 0points 0points 0points ## .. ..- attr(*, &quot;unit&quot;)= int 8 ## ..$ debug : logi FALSE ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ title : NULL ## $ aspect.ratio : NULL ## $ axis.title : NULL ## $ axis.title.x :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : NULL ## ..$ size : NULL ## ..$ hjust : NULL ## ..$ vjust : num 1 ## ..$ angle : NULL ## ..$ lineheight : NULL ## ..$ margin : &#39;margin&#39; num [1:4] 2.75points 0points 0points 0points ## .. ..- attr(*, &quot;unit&quot;)= int 8 ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ axis.title.x.top :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : NULL ## ..$ size : NULL ## ..$ hjust : NULL ## ..$ vjust : num 0 ## ..$ angle : NULL ## ..$ lineheight : NULL ## ..$ margin : &#39;margin&#39; num [1:4] 0points 0points 2.75points 0points ## .. ..- attr(*, &quot;unit&quot;)= int 8 ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ axis.title.x.bottom : NULL ## $ axis.title.y :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : NULL ## ..$ size : NULL ## ..$ hjust : NULL ## ..$ vjust : num 1 ## ..$ angle : num 90 ## ..$ lineheight : NULL ## ..$ margin : &#39;margin&#39; num [1:4] 0points 2.75points 0points 0points ## .. ..- attr(*, &quot;unit&quot;)= int 8 ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ axis.title.y.left : NULL ## $ axis.title.y.right :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : NULL ## ..$ size : NULL ## ..$ hjust : NULL ## ..$ vjust : num 1 ## ..$ angle : num -90 ## ..$ lineheight : NULL ## ..$ margin : &#39;margin&#39; num [1:4] 0points 0points 0points 2.75points ## .. ..- attr(*, &quot;unit&quot;)= int 8 ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ axis.text :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : chr &quot;grey30&quot; ## ..$ size : &#39;rel&#39; num 0.8 ## ..$ hjust : NULL ## ..$ vjust : NULL ## ..$ angle : NULL ## ..$ lineheight : NULL ## ..$ margin : NULL ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ axis.text.x :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : NULL ## ..$ size : NULL ## ..$ hjust : NULL ## ..$ vjust : num 1 ## ..$ angle : NULL ## ..$ lineheight : NULL ## ..$ margin : &#39;margin&#39; num [1:4] 2.2points 0points 0points 0points ## .. ..- attr(*, &quot;unit&quot;)= int 8 ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ axis.text.x.top :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : NULL ## ..$ size : NULL ## ..$ hjust : NULL ## ..$ vjust : num 0 ## ..$ angle : NULL ## ..$ lineheight : NULL ## ..$ margin : &#39;margin&#39; num [1:4] 0points 0points 2.2points 0points ## .. ..- attr(*, &quot;unit&quot;)= int 8 ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ axis.text.x.bottom : NULL ## $ axis.text.y :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : NULL ## ..$ size : NULL ## ..$ hjust : num 1 ## ..$ vjust : NULL ## ..$ angle : NULL ## ..$ lineheight : NULL ## ..$ margin : &#39;margin&#39; num [1:4] 0points 2.2points 0points 0points ## .. ..- attr(*, &quot;unit&quot;)= int 8 ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ axis.text.y.left : NULL ## $ axis.text.y.right :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : NULL ## ..$ size : NULL ## ..$ hjust : num 0 ## ..$ vjust : NULL ## ..$ angle : NULL ## ..$ lineheight : NULL ## ..$ margin : &#39;margin&#39; num [1:4] 0points 0points 0points 2.2points ## .. ..- attr(*, &quot;unit&quot;)= int 8 ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ axis.text.theta : NULL ## $ axis.text.r :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : NULL ## ..$ size : NULL ## ..$ hjust : num 0.5 ## ..$ vjust : NULL ## ..$ angle : NULL ## ..$ lineheight : NULL ## ..$ margin : &#39;margin&#39; num [1:4] 0points 2.2points 0points 2.2points ## .. ..- attr(*, &quot;unit&quot;)= int 8 ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ axis.ticks :List of 6 ## ..$ colour : chr &quot;grey20&quot; ## ..$ linewidth : NULL ## ..$ linetype : NULL ## ..$ lineend : NULL ## ..$ arrow : logi FALSE ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_line&quot; &quot;element&quot; ## $ axis.ticks.x : NULL ## $ axis.ticks.x.top : NULL ## $ axis.ticks.x.bottom : NULL ## $ axis.ticks.y : NULL ## $ axis.ticks.y.left : NULL ## $ axis.ticks.y.right : NULL ## $ axis.ticks.theta : NULL ## $ axis.ticks.r : NULL ## $ axis.minor.ticks.x.top : NULL ## $ axis.minor.ticks.x.bottom : NULL ## $ axis.minor.ticks.y.left : NULL ## $ axis.minor.ticks.y.right : NULL ## $ axis.minor.ticks.theta : NULL ## $ axis.minor.ticks.r : NULL ## $ axis.ticks.length : &#39;simpleUnit&#39; num 2.75points ## ..- attr(*, &quot;unit&quot;)= int 8 ## $ axis.ticks.length.x : NULL ## $ axis.ticks.length.x.top : NULL ## $ axis.ticks.length.x.bottom : NULL ## $ axis.ticks.length.y : NULL ## $ axis.ticks.length.y.left : NULL ## $ axis.ticks.length.y.right : NULL ## $ axis.ticks.length.theta : NULL ## $ axis.ticks.length.r : NULL ## $ axis.minor.ticks.length : &#39;rel&#39; num 0.75 ## $ axis.minor.ticks.length.x : NULL ## $ axis.minor.ticks.length.x.top : NULL ## $ axis.minor.ticks.length.x.bottom: NULL ## $ axis.minor.ticks.length.y : NULL ## $ axis.minor.ticks.length.y.left : NULL ## $ axis.minor.ticks.length.y.right : NULL ## $ axis.minor.ticks.length.theta : NULL ## $ axis.minor.ticks.length.r : NULL ## $ axis.line :List of 6 ## ..$ colour : chr &quot;black&quot; ## ..$ linewidth : &#39;rel&#39; num 1 ## ..$ linetype : NULL ## ..$ lineend : NULL ## ..$ arrow : logi FALSE ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_line&quot; &quot;element&quot; ## $ axis.line.x : NULL ## $ axis.line.x.top : NULL ## $ axis.line.x.bottom : NULL ## $ axis.line.y : NULL ## $ axis.line.y.left : NULL ## $ axis.line.y.right : NULL ## $ axis.line.theta : NULL ## $ axis.line.r : NULL ## $ legend.background :List of 5 ## ..$ fill : NULL ## ..$ colour : logi NA ## ..$ linewidth : NULL ## ..$ linetype : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_rect&quot; &quot;element&quot; ## $ legend.margin : &#39;margin&#39; num [1:4] 5.5points 5.5points 5.5points 5.5points ## ..- attr(*, &quot;unit&quot;)= int 8 ## $ legend.spacing : &#39;simpleUnit&#39; num 11points ## ..- attr(*, &quot;unit&quot;)= int 8 ## $ legend.spacing.x : NULL ## $ legend.spacing.y : NULL ## $ legend.key : NULL ## $ legend.key.size : &#39;simpleUnit&#39; num 1.2lines ## ..- attr(*, &quot;unit&quot;)= int 3 ## $ legend.key.height : NULL ## $ legend.key.width : NULL ## $ legend.key.spacing : &#39;simpleUnit&#39; num 5.5points ## ..- attr(*, &quot;unit&quot;)= int 8 ## $ legend.key.spacing.x : NULL ## $ legend.key.spacing.y : NULL ## $ legend.frame : NULL ## $ legend.ticks : NULL ## $ legend.ticks.length : &#39;rel&#39; num 0.2 ## $ legend.axis.line : NULL ## $ legend.text :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : NULL ## ..$ size : &#39;rel&#39; num 0.8 ## ..$ hjust : NULL ## ..$ vjust : NULL ## ..$ angle : NULL ## ..$ lineheight : NULL ## ..$ margin : NULL ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ legend.text.position : NULL ## $ legend.title :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : NULL ## ..$ size : NULL ## ..$ hjust : num 0 ## ..$ vjust : NULL ## ..$ angle : NULL ## ..$ lineheight : NULL ## ..$ margin : NULL ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ legend.title.position : NULL ## $ legend.position : chr &quot;right&quot; ## $ legend.position.inside : NULL ## $ legend.direction : NULL ## $ legend.byrow : NULL ## $ legend.justification : chr &quot;center&quot; ## $ legend.justification.top : NULL ## $ legend.justification.bottom : NULL ## $ legend.justification.left : NULL ## $ legend.justification.right : NULL ## $ legend.justification.inside : NULL ## $ legend.location : NULL ## $ legend.box : NULL ## $ legend.box.just : NULL ## $ legend.box.margin : &#39;margin&#39; num [1:4] 0cm 0cm 0cm 0cm ## ..- attr(*, &quot;unit&quot;)= int 1 ## $ legend.box.background : list() ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_blank&quot; &quot;element&quot; ## $ legend.box.spacing : &#39;simpleUnit&#39; num 11points ## ..- attr(*, &quot;unit&quot;)= int 8 ## [list output truncated] ## - attr(*, &quot;class&quot;)= chr [1:2] &quot;theme&quot; &quot;gg&quot; ## - attr(*, &quot;complete&quot;)= logi TRUE ## - attr(*, &quot;validate&quot;)= logi TRUE Code data %&gt;% mutate(percent_HLADR = HLADR/CD4) %&gt;% ggplot(aes(x=CD28, y=age, color = percent_HLADR)) + geom_point()+ theme_bw()+ scale_color_gradient(high = &quot;#FF0000&quot;, low = &quot;#0000FF&quot;) # you can search hex numbers, or match colours to a powerpoint presentation. You can use digital colour meter on Mac Code data %&gt;% mutate(percent_HLADR = HLADR/CD4) %&gt;% ggplot(aes(x=CD28, y=age, color = percent_HLADR)) + geom_point()+ theme_bw()+ scale_color_viridis_c() # you can search through the options for these, as well as other scale_color and scale_fill options. Annotating the plot Horizontal and Vertical lines: I’ve added vertical lines (vlines), where you can specify the xintercepts to draw lines through. I also added “annotate” layers where you can specify “text” or “segment” layers, with x, y and label arguments for Code data %&gt;% mutate(percent_CCR5 = 100*CCR5/CD4) %&gt;% ggplot(aes( x = group, y = percent_CCR5 ))+ geom_boxplot(width=0.5) + geom_jitter(width=0.1, alpha=0.2)+ labs( y= &quot;CCR5 %&quot;, x= &quot;Tissue x Layer&quot;)+ geom_vline(xintercept = c(2,4)+.5)+ annotate(&quot;segment&quot;, x=c(1:6)-.25, xend = c(1:6)+.25, y=data%&gt;% mutate(percent_CCR5 = 100*CCR5/CD4) %&gt;% group_by(group) %&gt;% summarise(mean = mean(percent_CCR5)) %&gt;% select(mean) %&gt;% unlist(), color=&quot;red&quot;, size=2)+ annotate(&quot;text&quot;, x=1:6, y=data%&gt;% mutate(percent_CCR5 = 100*CCR5/CD4) %&gt;% group_by(group) %&gt;% summarise(mean = mean(percent_CCR5)) %&gt;% select(mean) %&gt;% unlist(), label = data%&gt;% mutate(percent_CCR5 = 100*CCR5/CD4)%&gt;%group_by(group)%&gt;%summarise(mean=mean(percent_CCR5)) %&gt;% select(mean) %&gt;% unlist() %&gt;%round(), hjust = -2, color=&quot;red&quot;)+ theme_classic() facet_wrap() and Group Facet wrap lets you split your points by a categorical value Facet_wrap(): Code data %&gt;% mutate(percent_HLADR = 100*HLADR/CD4) %&gt;% ggplot(aes(x=CD28, y=age, color = percent_HLADR)) + geom_point(aes(shape=layer))+ theme_bw()+ scale_color_gradient(high = &quot;#FF0000&quot;, low = &quot;#0000FF&quot;)+ facet_wrap(~tissue) plot_grid(): Code library(cowplot) plot1 = data %&gt;% mutate(percent_CCR5 = 100*CCR5/CD4) %&gt;% ggplot(aes( x = group, y = percent_CCR5 ))+ geom_boxplot(width=0.5) + geom_jitter(width=0.1, alpha=0.2)+ labs( y= &quot;CCR5 %&quot;, x= &quot;Tissue x Layer&quot;, title=&quot;Percent CCR5&quot;)+ geom_vline(xintercept = c(2,4)+.5)+ theme_classic() plot2 = data %&gt;% ggplot(aes( x = group, y = log(CCR5_MFI) ))+ geom_boxplot(width=0.5) + geom_jitter(width=0.1, alpha=0.2)+ labs( y= &quot;log(CCR5 MFI)&quot;, x= &quot;Tissue x Layer&quot;, title=&quot;CCR5 MFI&quot;)+ geom_vline(xintercept = c(2,4)+.5)+ theme_classic() plot_grid(plot1,plot2, nrow=2) #or change the rows. Add 50 plots if you want to adn specify how you arrange them by rows and/or columns Saving plots You can save plots in a few ways. pdf/png/tiff/jpeg(): Use ?png to get the specific options, but here is a simple example of generating a multipage pdf. You call the function to “open” the pdf, plot your figures, and then close the pdf using dev.off() Code pdf(file=&quot;CCR5_results.pdf&quot;, widht = 7, height=7) data %&gt;% mutate(percent_CCR5 = 100*CCR5/CD4) %&gt;% ggplot(aes( x = group, y = percent_CCR5 ))+ geom_boxplot(width=0.5) + geom_jitter(width=0.1, alpha=0.2)+ labs( y= &quot;CCR5 %&quot;, x= &quot;Tissue x Layer&quot;, title=&quot;Percent CCR5&quot;)+ geom_vline(xintercept = c(2,4)+.5)+ theme_classic() data %&gt;% ggplot(aes( x = group, y = log(CCR5_MFI) ))+ geom_boxplot(width=0.5) + geom_jitter(width=0.1, alpha=0.2)+ labs( y= &quot;log(CCR5 MFI)&quot;, x= &quot;Tissue x Layer&quot;, title=&quot;CCR5 MFI&quot;)+ geom_vline(xintercept = c(2,4)+.5)+ theme_classic() dev.off() ggsave: ggsave is quite simple and allows you to very easily control resolutions and size. Code ggsave(&quot;CCR5_percent.png&quot;, plot1, path = &quot;C:/1_Yc/r-analysis-user-group/plots&quot;, width = 7, height = 5, units = c(&#39;cm&#39;), dpi=300) Some final hints   • You can use show.legend=F inside geom layers to remove the legends   • You can store your initial plots as plot = ggplot(...)+geom_...     and then append layers onto this. Next Chapter → "],["chapter-7-statistical-analysis.html", "Chapter 7: Statistical Analysis Descriptive statistics", " Chapter 7: Statistical Analysis Goals: Apply simple statistic to the synthetic data.   • Descriptive statistics: mean, median, mode.   • Hypothesis testing (t-tests, ANOVA).   • Correlation and regression. Read time: 15 Minutes Descriptive statistics As the name suggests, in descriptive stats you can observe and describe the features of the exact data that you collected. You can quickly check some stats like mean, standard deviation (SD) and standard error (SE), median and 1st and 3rd quartile. Code SE &lt;- function(x){sd(x)/sqrt(length(x))} data %&gt;% mutate(percent_CD4 = 100*CD4/CD3)%&gt;% group_by(group) %&gt;% summarise(mean = mean(percent_CD4), sd = sd(percent_CD4), se = SE(percent_CD4), min = min(percent_CD4), quantile_25 = quantile(percent_CD4, probs = 0.25), median = median(percent_CD4), quantile_75 = quantile(percent_CD4, probs = 0.75), max = max(percent_CD4)) %&gt;% print() data %&gt;% mutate(percent_CD4 = 100*CD4/CD3)%&gt;% ggplot(aes(group, percent_CD4))+geom_boxplot()+ theme_classic() More content coming soon! "],["chapter-8-reproducible-reports-with-rmarkdown.html", "Chapter 8: Reproducible Reports with RMarkdown", " Chapter 8: Reproducible Reports with RMarkdown Content coming soon! "],["conclusions.html", "Conclusions", " Conclusions Content coming soon! "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
