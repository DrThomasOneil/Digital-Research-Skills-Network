[["index.html", "Introduction to R and analytic Programming Welcome!", " Introduction to R and analytic Programming Yuchen Li &amp; Thomas O’Neil 2024-12-23 (Last update: 2025-02-04) Welcome! This is the sub-repository containing the tutorials and workshop notes for the introduction to R and analytic programming. Get started → "],["introduction.html", "Introduction Transitioning from manual tools (e.g. Excel &amp; Prism) to programming-based workflows in R. Handling data - be specific! Directories Reproducibility and automation", " Introduction Leaving behind manual analysis tools Goals: Introduce programming concepts and the mindset behind programmatic workflows.   • Transition from manual tools (e.g. Excel &amp; Prism) to programming-based workflows in R.   • Understand the concept of handling data using code.   • Learn to navigate directories and file paths programmatically.   • Emphasise reproducibility and structured workflows. You will not be writing any code in this introduction. Instead, we will focus on reframing how you approach analytic programming. These ideas are tailored to researchers who manage a variety of tools — FlowJo, Excel, Prism, and more — but want to unify data wrangling, visualisation, and reporting under a single environment. Read time: 10 Minutes Transitioning from manual tools (e.g. Excel &amp; Prism) to programming-based workflows in R. Many resources teach the basics of R programming, but here we view things through the lens of a wet-lab researcher dealing with biomedical data. We will go beyond basic statistical methods or standard single-cell workflows and include topics like building a lab notebook in R and collaborating with PIs or peers. If, however, all you need is a quick, “click-and-run” script to load already processed data, you might prefer resources such as this and that. Note: If you still do not get it, don’t worry. It took me years to feel comfortable. I was fortunate enough to have a supervisor who gave me time to learn this. Keep up with it, find more resources and stick with a good community of users :) Consistency Consistency is key. You won’t get significantly more efficient without practice. You may find that when you routinely use a particular analysis, you can rewrite the entire workflow from memory. But after a break, it’s normal to forget key steps. Programming efficiency builds incrementally—there’s no shortcut. Active Learning Learning to code is like learning a foreign language: practicing by “speaking” (i.e. actually writing and running code) is far more effective than just reading. Do not limit yourself to reading code in a book—actively write and test it. One advantage of programming is that mistakes stay private to you and your computer. Embrace that safe space to experiment. Fortunately, we don’t have to embarrass ourselves when we try the wrong combination of words in programming (the only people who will know your silliness is you and ChatGPT). Avoid Tutorial Overload Be cautious about endless tutorials that don’t match your research needs. If example data is far removed from your work (like sports or finance data), you might struggle to see how it helps with, say, flow cytometry. Seek practice with examples relevant to your actual data and objectives. Handling data - be specific! Unlike with Excel or Prism, you won’t be double-clicking cells. If you want to change the value in the 3rd column and 5th row, you’ll need an explicit instruction like: my_data[5,3] &lt;- new_value … and so you’ll need to learn quickly to be specific. Eventually, you’ll learn to automate repetitive tasks, such as finding all rows containing “CD45RA” or “CD4.” Before long, you’ll understand that formatting data consistently—e.g. avoiding spaces in column names—saves you from constant reformatting or code breakage. An accidental space in something like Sample Number becomes Sample.Number, and your existing scripts may fail. Before using R, I spent countless hours copy/pasting to get data formatted for Prism. If you’ve had that frustration, learning consistent data formatting for R can prevent a lot of manual effort. I hope that as you navigate through these lessons, you try to amend your own spreadsheets so that your data becomes an R-friendly format. Directories Forget double-clicking in File explorer &amp; Finder! When you open RStudio, you’re essentially using a text editor (with syntax highlighting) that executes code. If R is pointed to the wrong folder, you may accidentally open or overwrite the wrong files. Could you imagine thinking that you’re editing row 5 and column 3 of your raw data, and not realising that you’re editing the tissue log! Directories are the most common errors! For both beginner and experienced users! Set your directory at the beginning of each script/session! For these sessions, I’ve created a folder on my desktop (mac) called analysis_user_group. We want to tell R where to look for files/folders and where to save our data/plots. setwd(&quot;~/Desktop/analysis_user_group&quot;) I can check my working directory using getwd() [1] \"/Users/thomasoneil/Desktop/analysis_user_group\" You can verify which files are present by using list.files() Note on “.” and “..” In a directory path, . means “this directory” and .. means “the parent directory.” For instance, list.files(“..”) will list files in the folder above your current one. Reproducibility and automation Tracking every minor change in a spreadsheet—removing rows, shifting columns, or redoing analyses in FlowJo—can be tedious. By contrast, each line of code in R is an explicit instruction, and you can save or version your script to see exactly what was done. Any time you need to adjust or repeat the analysis, you can simply run the script again. Even better, you can automate many analyses. Once you have a working script, just change the folder path (and data, if needed), and you can generate a fresh report for new experiments. Combine multiple R scripts into a Markdown book to share with collaborators or keep for your records. This alone makes programming worthwhile: reproducibility is seamless, and the clarity you gain over your data transformations is invaluable. Next Chapter → "],["chapter-1-getting-started-in-r-and-rstudio.html", "Chapter 1: Getting Started in R and RStudio R as a programming language Installing R and RStudio Navigating RStudio Projects Using R Hello World Optional Exercise: Write your first second script Next Chapter", " Chapter 1: Getting Started in R and RStudio Your first steps… Goals: Set up R and RStudio, and get familiar with the interface.   • Understand what a programming language is.   • Know the difference between R, RStudio and python.   • Install R and RStudio.   • Exploring the interface – Console, Environment, Scripts.   • Installing and loading packages.   • Start your first project. By the end of this chapter, you’ll have installed R and RStudio, know how to navigate the RStudio UI and will know how to get started on a new project. To start with… Create a folder that you’ll work out of for this tutorial. For example, I have a folder analysis-user-group on my Desktop. Read time: 30 Minutes R as a programming language Simply: A programming language is a way to communicate with a computer. There are many languages, each with their own advantages and limitations. Some, such as SQL are used in database management, and others like R and python are used for analytic programming. R is designed specifically for statistical computing, data analysis and visualisation, and is considered one of the more user-friendly languages. Python is more of a general-purpose language used in data science, but also for web development, machine learning, and more. The language itself needs an interface for you to communicate with the computer. You can run R in Terminal (Mac) or Command Prompt (Windows) if you wanted to. You could store your scripts in Word and then copy and paste the lines into the commandline window. By now, you’ve heard of and seen RStudio. RStudio is what’s called an Integrated Development Environment (IDE) and makes working with R easier by organizing scripts, plots, and files. Installing R and RStudio Install R first. Go to CRAN, download the latest version of R and follow the prompts to install on your computer. You don’t need to do anything else with the R application! Next install RStudio. Go to the download page and follow the prompts to install on your computer. Once installed, open RStudio—it should automatically connect to your R installation. Navigating RStudio When you first open RStudio, you’ll see four main panels: Console (Bottom Left): This is essentially R. This is where you run the code. Environment (Top Right): Keeps track of your variables and data. Files/Plots/Packages (Bottom Right): Displays file directories, plots, help pages, and packages. Script Editor (Top Left): This is simply a text editor. This is where you would write and save your code. We will now start using R. You will be able to copy and paste code either directly into the console or into a new script, which you can save for later! Projects Projects in RStudio help organize your files and workflows. Create a Project: Go to File &gt; New Project. Select New Directory or link to an Existing Directory. Name your project and choose a folder location. Click Create Project. This sets up a workspace, saving all files and settings in one place. Use projects to keep analyses organized and reproducible. Using R It might feel like we’re moving too quickly through some of this. Don’t worry! The next few chapters will go into variables, data structures, functions and so on in more details using mock data. chunk: I’ll refer to the blocks of code you see throughout these lessons as a chunk. function: A function is a set of statements that are run at the same time. argument: An argument is a value/variable used in a function. package: A package is simply a collection of functions. R as a programming language is a set of basic functions. Some of these include: Arithmetic Code # sums 1+1 ## [1] 2 Code # subtraction 3-1 ## [1] 2 Code # multiplication 2*2 ## [1] 4 Code # division 40/pi ## [1] 12.7324 Code # exponents 2^2 ## [1] 4 Print and Paste Code # print a sentence print(&quot;This is a sentence.&quot;) ## [1] &quot;This is a sentence.&quot; Code # print two things &#39;pasted&#39; together print(paste(&quot;This is pi:&quot;, pi)) ## [1] &quot;This is pi: 3.14159265358979&quot; print() and paste() are examples of base R functions. DoHeatmap() and NormalizeData() are examples of functions that are derived from the Seurat package, used for scRNA seq analysis We might combine a series of these base R functions to create unique and specific output. For example, lets say I was constantly calculating cell percentages based off of cell numbers, and want to output a sentence summary. I might write it like this each time: Code num_cd45 = 45000 # number of CD45+ cells num_cd3 = 22000 # number of CD3+ cells per_cd3 = num_cd3/num_cd45 # calculate the fraction per_cd3 = per_cd3*100 # multiply by 100 to get a percentage per_cd3 = round(per_cd3, digits=2) # round the data off - here is an example of an argument - I can specify how many digits I want to include paste(&quot;There are &quot;, num_cd45, &quot; CD45+ cells and &quot;, num_cd3, &quot; CD3+ cells (&quot;, per_cd3, &quot;%)&quot;, sep = &quot;&quot;) # output the statement ## [1] &quot;There are 45000 CD45+ cells and 22000 CD3+ cells (48.89%)&quot; I would have several samples to calculate these for, and I don’t want to repeat these lines of code n times! We could write this into our own function (I will demonstrate how to do this in a future lesson) or hopefully someone has already done this. Lets pretend… …someone has already solved this issue. They’ve written the functions that we want and published them as package called simple_math. We would install this package and have access to the functions. Code # install the package install.packages(&quot;simple_math&quot;) A package only needs to installed once! You can manually search for your packages in RStudio in the Packages tab on the right. Or simply try to load it using… Code # load the package library(simple_math) You will need to load packages into your R sessions every time you restart R Now that simple_math is loaded into our session, we could use the functions within the package. This is what the function might look like: Code calculate_percent( parent = &quot;CD45&quot;, parent_num = 45000, subset = &quot;CD3&quot;, subset_num = 22000, digits = 1 ) ## [1] &quot;There are 45000 CD45+ cells and 22000 CD3+ cells (48.9%)&quot; This is a super reductionist explanation of functions and packages. Not only do functions and packages use base R functions, they themselves require functions from other packages. E.g. the Seurat package uses ggplot functions to generate graphs. As you perform more and more complex analyses, you will be installing and loading more and more packages necessary. There are some very common packages that you’ll likely use a lot such as: ggplot2 for visualisation dplyr for data manipulation Seurat for single cell analysis BiocManager for installing additonal bioinformatic packages … etc, etc Commenting code: You might have noticed that within the R chunks. Comments are ways of adding details and descriptions to your otherwise dry code. They are prefaced by a # The can be used in two ways: On their own line     # this is a comment     1+1     [1] 2 After code     1+1 # this will add 1 to 1     [1] 2 It is incredibly useful to comment your code. Some examples may be: You’ve written a script or custom function and want to remember what each line does. You’ve written a script or custom function and want to inform others what each line does. You’ve changed a script, but want to keep a copy of the older version - you could comment out each line. etc etc Hello World It’s customary that your first script is helloworld.R. So! Open a new script and save it in your analysis-user-group folder as helloworld.R. In this script add the line: Code print(&quot;Hello World&quot;) Click on this line in your script editor and press: Mac: Command-Enter Windows: Control-Enter This sends the line you’re on to the console and runs it. You’ll get the output [1] &quot;Hello World&quot; Congratulations. You wrote your first program.You’re a genius.Well done.You’re on your way to becoming a superstar programmer. Optional Exercise: Write your first second script Practice:   Create an R script.          Send a line to the console. (See Hello World above)          Set your directory.          Install the ggplot2 package.          Load in sthe ggplot2 packages.          Download the dataset used for these tutorials into my directory.          Load in the dataset.          Inspect the data.          Create a simple plot of the data.          Save the plot in your directory. The data: In this exercise, and throughout these tutorials, we’ll be using flow cytometry data I synthesised representing mock cell frequencies and expressions of T cells dervied from human tissues (n=60). The data dictionary below provides a description for each column Data Dictionary: Column Description date Date of acquisition experiment Experiment number donor Donor Number age Age of patient tissue Tissue type: abdomen, labia, vagina layer Tissue layer: epithelium, underlying mucosa group Summarised sample group (e.g. A_E = abdomen epithelium) CD3 CD3+ cells CD8 CD8+ cells CD4 CD4+ cells HLADR CD4+HLADR+ cells CCR5 CD4+CCR5+ cells HLADR_MFI gMFI of HLADR on CD4+ cells CCR5_MFI gMFI of CCR5 on CD4+ cells CD28 CD4+CD28+ cells gMFI:geometric mean fluorescent intensity. Exercise: Write a script using the following instructions (run the lines as you write to see if its working for you) Open a new R script and save it to a folder of your choice. At the top of each of your scripts, you might want to add some comments about what the script is for. Set your working directory using setwd(). One way to quickly find the directory is to copy the folder and paste it into the script itself. Install ggplot2 Load the ggplot2 package Download the example data using: Code download.file(url=&quot;https://raw.githubusercontent.com/DrThomasOneil/analysis-user-group/refs/heads/main/docs/r-tutorial/assets/synthetic_data.csv&quot;, destfile=&quot;synthetic_data.csv&quot;) Don’t see the file? If you have set your directory properly, you will see a new file in your folder called synthetic_data.csv. Load the data into R using data &lt;- read.csv(\"synthetic_data,csv\") Inspect the data colnames() will show you what columns are present dim(data) will show you the dimensions of the data as rows x columns. head(data) will show you the first 6 rows of the data. Conversely, you could use tail(). summary(data) will give you detailed output of the data. Assign to a variable plot a graph of % CD4+ T cells in each group using the ggplot() function. Here you can copy and paste my code, as we don’t cover ggplot until Chapter 5 In Chapter 5 &amp; 6, we will learn how to use ggplot and how to make publication-worthy graphs Code plot = ggplot(data, aes(x=group, y=100*(CD4/CD3), color=tissue))+geom_boxplot() Output the plot by writing plot in the console. Save the plot to your directory using ggsave(). Use ?ggsave in the console to bring up the help menu for this function! Here you will find descriptions of the function, the arguments you can use and examples of it’s use. Solution Here is one possible solution. Did you comment your code? Code #* This is my first script #* I will set my directory, install my first package, load it in, and save a variable to my directory #* 20250107 # set your directory setwd(&quot;~/Desktop/analysis-user-group&quot;) #THIS WONT WORK FOR YOU - YOU&#39;LL NEED TO SET YOUR OWN DIRECTORY # uncomment and install the package once # install.packages(&quot;ggplot2&quot;) # load the package library(ggplot2) # download the example data download.file(url=&quot;https://raw.githubusercontent.com/DrThomasOneil/analysis-user-group/refs/heads/main/docs/r-tutorial/assets/synthetic_data.csv&quot;, destfile = &quot;synthetic_data.csv&quot;) # read in synthetic data data &lt;- read.csv(&quot;synthetic_data.csv&quot;) # inspect the data colnames(data) dim(data) head(data) summary(data) # create a simple plot of percentage of CD4+ cells per group plot &lt;- ggplot(data, aes(x=group, y=100*(CD4/CD3), color=tissue))+geom_boxplot() # output the plot plot # save plot ggsave(&quot;myfirstplot.png&quot;,plot = plot) You may have seen me use = and &lt;- interchangeably. That’s because they are. Next Chapter Congratulations! You’ve completed Chapter 1. You now have R and RStudio installed, have installed a package and started to write scripts. In the next two chapters, I will use this data to explain more about the fundamentals of R. Next Chapter → "],["chapter-2-data-types-and-structures.html", "Chapter 2: Data Types and Structures Data Types Data Structures Importing and saving files in R", " Chapter 2: Data Types and Structures Goals: Learn about data types and structures in R.   • Basic data types: numeric, character, logical.   • Data structures: vectors, matrices, data frames, lists.   • Assessing and querying data types and structures.   • Importing data (RDS, Excel, CSV files). Read time: 15 Minutes Data Types There are a few data types you should know: character: In R, characters or strings are letters, words, sentences, numbers, symbols… They’re defined using quotation marks. numeric: Data can be stored as a number. R recognises numbers without the quotation marks logical: TRUE / FALSE / T / F / 1 / 0. Logicals are an important data type that you’ll notice along the way. R treats 1 as TRUE and 0 as FALSE Some functions or operations require data to be of the correct type. For example, mathematical operations can’t be performed on a character. Code # character char = &quot;Hello World&quot; typeof(char) ## [1] &quot;character&quot; Code # numeric num = &quot;1&quot; typeof(num) # &quot;1&quot; is enclosed in quotes, so it is a character string. ## [1] &quot;character&quot; Code num = 1 typeof(num) # without the quotes ## [1] &quot;double&quot; Code # logical log = TRUE typeof(log) ## [1] &quot;logical&quot; A good example of using logicals is to check a condition and execute a script. I’ll use if here, which we cover in the next chapter. Examples: Code # TRUE run_script = TRUE if(run_script) { print(paste0(&quot;run_script is &quot;, run_script)) } ## [1] &quot;run_script is TRUE&quot; Code run_script = T if(run_script) { print(paste0(&quot;run_script is &quot;, run_script)) } ## [1] &quot;run_script is TRUE&quot; Code run_script = 1 if(run_script) { print(paste0(&quot;run_script is &quot;, run_script)) } ## [1] &quot;run_script is 1&quot; Code # FALSE run_script = FALSE if(run_script) { print(paste0(&quot;run_script is &quot;, run_script)) } run_script = F if(run_script) { print(paste0(&quot;run_script is &quot;, run_script)) } run_script = 0 if(run_script) { print(paste0(&quot;run_script is &quot;, run_script)) } Above, we set the variables deliberately to demonstrate how they can be used. However, they don’t need to be deliberately set to be useful. Code a = 3 typeof(a) ## [1] &quot;double&quot; Code is.numeric(a) ## [1] TRUE Code typeof(is.numeric(a)) ## [1] &quot;logical&quot; Code if(is.numeric(a)){ print(paste0(&quot;The variable a (&quot;, a,&quot;) is numeric.&quot;)) } ## [1] &quot;The variable a (3) is numeric.&quot; Code a=&quot;3&quot; if(is.numeric(a)){ print(paste0(&quot;The variable a (&quot;, a,&quot;) is numeric. Continuing the analysis.&quot;)) } else { print(paste0(&quot;The variable a (&quot;, a,&quot;) is &quot;, typeof(a), &quot;. Not continuing the analysis.&quot;)) } ## [1] &quot;The variable a (3) is character. Not continuing the analysis.&quot; Data Structures Data types can be organised into structures. These are: vectors: A vector is a collection of data, such as c(1990, 1990, 1991, 1989) or c(“Rou”, “Chris”, “Rory”, “Rob”) matrix: A matrix is data organised into rows and columns. Data in a matrix is only of one data type. data frames: A data frame is similar to a matrix, but can contain different data types. lists: A list is dynamic and can hold all different types of data structures and data types. Code yr &lt;- c(1990, 1990, 1991, 1989) name &lt;- c(&quot;Rou&quot;, &quot;Chris&quot;, &quot;Rory&quot;, &quot;Rob&quot;) rating &lt;- c(4,4,4,5) df &lt;- data.frame(year = yr, names = name, ratings = rating) df Code dim(df) ## [1] 4 3 We can see this dataframe is 4 rows tall and 3 columns wide. We can access information in a dataframe using: df[row, col] Code df[1,1] ## [1] 1990 With data frames, we can also use $ to query a specific column. Code df$names ## [1] &quot;Rou&quot; &quot;Chris&quot; &quot;Rory&quot; &quot;Rob&quot; More examples: Code # show all rows in certain columns df[,1] ## [1] 1990 1990 1991 1989 Code df[,&quot;names&quot;] ## [1] &quot;Rou&quot; &quot;Chris&quot; &quot;Rory&quot; &quot;Rob&quot; Code # show all columns in one row df[1,] # show select columns by providing a vector of specific indices df[,c(1,3)] # provide a range of indices quickly using colon between numbers. e.g. 1 to 2 df[,c(1:2)] # instead of using indices to pull information, we can use logic df[c(T,T,F,T),] We can do a lot with a data frame if we combine everything we know about data types and structures Code # store a row or column as a new object patient_1 = df[1,] patient_1 # return a logical vector based on a query df$names == &quot;Rou&quot; ## [1] TRUE FALSE FALSE FALSE Code # and add this to a new column df$is_rou &lt;- df$names == &quot;Rou&quot; df # With a large dataframe, we might not know the specific indices we want to see or store, # so we could cut a dataframe or pull information based on certain logic df[df$names==&quot;Rou&quot;,] df[df$ratings&lt;5,] When working with enormous data structures, like single cell sequencing or proteomics data, knowing how to query your data frame or matrix will be very useful! Finally, we can make a list out of all of these different data types and structures, Code list &lt;- list(&quot;number&quot; = 1, &quot;string&quot; = &quot;string&quot;, &quot;logical&quot; = TRUE, &quot;vector&quot; = name, &quot;dataframe&quot; = df) list ## $number ## [1] 1 ## ## $string ## [1] &quot;string&quot; ## ## $logical ## [1] TRUE ## ## $vector ## [1] &quot;Rou&quot; &quot;Chris&quot; &quot;Rory&quot; &quot;Rob&quot; ## ## $dataframe ## year names ratings is_rou ## 1 1990 Rou 4 TRUE ## 2 1990 Chris 4 FALSE ## 3 1991 Rory 4 FALSE ## 4 1989 Rob 5 FALSE Ways to query your list Code list[[1]] ## [1] 1 Code list[[&quot;vector&quot;]] ## [1] &quot;Rou&quot; &quot;Chris&quot; &quot;Rory&quot; &quot;Rob&quot; Code list$string ## [1] &quot;string&quot; Its also worth noting that lists can contain other lists. Code list$nested_list &lt;- list(a = 1, b = c(2, 3, 4)) Importing and saving files in R Most file types can be read into R. If you’re not working with xlsx or csv, you might be working with tsv, txt, h5ad, or xml. Some are easier than others, and you’ll learn them as you go. Another file type is RDS which is R Data Serialization which is the easiest and most efficient way to read and write data once you’ve got it in R. RDS is more efficient than csv because saving and writing a csv is not as standard as you think. For example, a column name might change, rownames don’t stick unless directly specified when reading it back in. On the other hand, saveRDS() &amp; readRDS() requires no extra information. Your data will be identical when read back in. Most commonly, you’ll use either data &lt;- read.csv() # For CSV files data &lt;- readRDS() # For RDS files To read in excel files, you’ll need to install a package (try the packages xlsx for read.xlsx(), or readxl for read_excel() - I can’t recall why, but sometimes one of these won’t work). Throughout these tutorials, you’ll use read.csv() to read in the example data we downloaded in Chapter 1. We’ll then finish each tutorial with saveRDS() and begin the next tutorial with readRDS(). This is a nice and organised way that you may use yourself when analysing data. This is effectively having stop and start points. Next chapter → "],["chapter-3-basic-programming.html", "Chapter 3: Basic Programming Assigning variables Conditional statements Loops Writing a function", " Chapter 3: Basic Programming Goals: Understand programming logic for automating tasks.   • Variables and assignments.   • Conditional statements (if, else).   • Loops (for, while).   • Writing functions. Read time: 10 Minutes Assigning variables We’ve already introduced variable assignment, where a value is stored in a named object. For example, a &lt;- 3 assigns the value 3 to a. We’ve also already assigned dataframes and lists to objects too. This allows us to store and reuse information efficiently, reducing redundancy in our code. You can store anything you might want to use later, but remember that you will continuously take up more and more space with every object and variable you save. Code setwd(&quot;directory&quot;) Code data &lt;- read.csv(&quot;~/Desktop/analysis-user-group/synthetic_data.csv&quot;) Keep an eye on your environment. It will inflate quickly. You can use rm(object1, object2, objectn) to remove objects from your environment. Conditional statements Conditional statements allow you to control the flow of your code by executing different actions based on specific conditions. Code data$predominant_subset &lt;- ifelse( # Unlike an if statement that evaluates a single condition, ifelse() is vectorized and applies the condition across an entire column. data$CD8 &gt; data$CD4, #Condition &quot;CD8&quot;, # if condition is met, this is the outcome &quot;CD4&quot; # ELSE this is the outcome. ) # get a quick summary of these results table(data$predominant_subset, data$layer, data$tissue) ## , , = Abdomen ## ## ## Epithelium Underlying ## CD4 5 0 ## CD8 19 24 ## ## , , = Labia ## ## ## Epithelium Underlying ## CD4 0 20 ## CD8 20 0 ## ## , , = Vagina ## ## ## Epithelium Underlying ## CD4 0 16 ## CD8 16 0 You can see that there are several variations of the Abdomen tissue type, likely as a result of human input error when adding data to the csv. We’ll fix these below using loops. Loops There are two main types of loops in R: - For loops: Used when the number of iterations is known. E.g. for indexes in 1 through 100, print which index you’re up to written as for(index in 1:100){print(index)} While loops: Used when iterations depend on a condition. E.g. while the index is less than or equal to 100, print the index written as: Code index=1 while(index &lt;=100){ print(index) index=index+1 } Here’s an example of a loop checking for inconsistent tissue labels. Code n_vagina = 0 n_labia = 0 n_abdo = 0 for(index in 1:nrow(data)){ #loop from 1 through nrows in data (1,2,3...121,120) and assign this value to &#39;index&#39; if(data$tissue[index] == &quot;Abdomen&quot;){ #check if the string at row[index] in the &#39;tissue&#39; column matches abdomen. n_abdo = n_abdo+1 #If so, add 1 to the variable. } else if(data$tissue[index] == &quot;Labia&quot;){ # repeat n_labia=n_labia+1 } else if(data$tissue[index] == &quot;Vagina&quot;){ n_vagina=n_vagina+1 } else { print(paste(data$tissue[index], &quot;at index&quot;,index,&quot;does not match Abdomen, Labia or Vagina.&quot;)) # print a statement if the condition is met. } } print(paste0(n_vagina, &quot; vagina samples. &quot;, n_labia, &quot; labia samples. &quot;, n_abdo, &quot; abdomen samples. (Total: &quot;,n_abdo+n_labia+n_vagina,&quot;)&quot; )) ## [1] &quot;32 vagina samples. 40 labia samples. 48 abdomen samples. (Total: 120)&quot; We know that there are 120 samples, but here it’s printing 117, because there are 3 instances where Abdomen are not found (written abdomen, or Abdo). This will be a headache when generate plots or statistics. We could change these manutally, but I’ll write a function below which finds those errors and lets the user change the value. Writing a function Functions help modularize your code, reducing repetition and improving readability. Instead of rewriting similar blocks of code, you can define a function and call it whenever needed. For example, with single cell RNA analysis with Seurat, if you’re testing different variables, having the workflow summarized in one function will make your workflow tidier. Here we’re just going to write the checker above into a function with some extra user-input functionality. Code sample_counter &lt;- function(data){ n_vagina = 0 n_labia = 0 n_abdo = 0 for(index in 1:nrow(data)){ #loop from 1 through nrows in data (1,2,3...121,120) and assign this value to &#39;index&#39; if(data$tissue[index] == &quot;Abdomen&quot;){ #check if the string at row[index] in the &#39;tissue&#39; column matches abdomen. n_abdo = n_abdo+1 #If so, add 1 to the variable. } else if(data$tissue[index] == &quot;Labia&quot;){ n_labia=n_labia+1 } else if(data$tissue[index] == &quot;Vagina&quot;){ n_vagina=n_vagina+1 } else { print(paste(data$tissue[index], &quot;at index&quot;,index,&quot;does not match Abdomen, Labia or Vagina.&quot;)) checkval=0 while(checkval==0){ input = readline(&quot;Choose correct value: [1] Abdomen, [2] Labia, [3] Vagina. &quot;) if(input %in% c(1:3)) { if(input==1){ n_abdo = n_abdo+1 data$tissue[index] = &quot;Abdomen&quot; } else if(input==2) { n_labia=n_labia+1 data$tissue[index] = &quot;Labia&quot; } else if(input==3) { n_vagina=n_vagina+1 data$tissue[index] = &quot;Vagina&quot; } checkval = 1 #exit the while loop } else { cat(&quot;\\nIncorrect input. Try again.\\n&quot;) } } } } print(paste0(n_vagina, &quot; vagina samples. &quot;, n_labia, &quot; labia samples. &quot;, n_abdo, &quot; abdomen samples. (Total: &quot;,n_abdo+n_labia+n_vagina,&quot;)&quot; )) return(data) } Code data &lt;- sample_counter(data) 1 1 1 write.csv(data, &quot;~/Desktop/analysis-user-group/synthetic_data.csv&quot;) Throughout your analysis, you’ll find more relevant for loops, while loops and functions that make you more efficient at programming. Next chapter → "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
