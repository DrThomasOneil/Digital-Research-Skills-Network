

# Chapter 3: Basic Programming

<div class="hint-goals">      
**Goals:**     
Understand programming logic for automating tasks.   
&nbsp;&nbsp;&#8226; Variables and assignments.    
&nbsp;&nbsp;&#8226; Conditional statements (`if`, `else`).    
&nbsp;&nbsp;&#8226; Loops (`for`, `while`).   
&nbsp;&nbsp;&#8226; Writing functions.    
</div>

<read-time><i>**Read time**: 10 Minutes</i></read-time>

<wimr>

## Assigning variables

We've already demonstrated variables and assignment. What we mean by this is `a <- 3`, where we assign the variable `3` to `a`. We've also already assigned dataframes and lists to `objects` too.

In short, we do this to store and use information a lot more efficiently. You can store anything you might want to use later, but remember that you will continuously take up more and more space with every object and variable you save.

```{r, include=F}
setwd("~/Desktop/analysis-user-group")
```

```{r, eval=F}
setwd("directory")
```

```{r}
data <- read.csv("~/Desktop/analysis-user-group/synthetic_data.csv")
```


<wimr>

## Conditional statements

Conditional statements let you break up and execute your code based on different conditions, such as `if` and `else`. 

```{r}
data$predominant_subset <- ifelse(
  data$CD8>data$CD4, #Condition
  "CD8", # if condition is met, this is the outcome
  "CD4" # ELSE this is the outcome. 
)

# get a quick summary of these results
table(data$predominant_subset, data$layer, data$tissue)
```

You can see that there are several variations of the **Abdomen** tissue type, likely as a result of human input error when adding data to the csv. We'll fix these below using loops. 

## Loops

With loops, we can iterate functions over a dataset, such as number of rows and number of columns, or number of samples in a folder. There are two types:

- `for` which will iterate a specified number of times. 
  - E.g. *for indexes in 1 through 100, print which index you're up to* written as `for(index in 1:100){print(index)}`
  
- `while` which will iterate indefinitely until a condition is not met. E.g. *while the index is less than or equal to 100, print the index* written as 

```r
index=1
while(index <=100){
  print(index)
  index=index+1
}
```

Here is an example of using a loop and a check which indexes are coming up with differences. 
```{r}
n_vagina = 0
n_labia = 0
n_abdo = 0

for(index in 1:nrow(data)){ #loop from 1 through nrows in data (1,2,3...121,120) and assign this value to 'index'
  if(data$tissue[index] == "Abdomen"){ #check if the string at row[index] in the 'tissue' column matches abdomen. 
    n_abdo = n_abdo+1 #If so, add 1 to the variable. 
  } else if(data$tissue[index] == "Labia"){ # repeat
    n_labia=n_labia+1
  } else if(data$tissue[index] == "Vagina"){
    n_vagina=n_vagina+1
  } else {
    print(paste(data$tissue[index], "at index",index,"does not match Abdomen, Labia or Vagina.")) # print a statement if the condition is met.
  }
}

print(paste0(n_vagina, " vagina samples. ", n_labia, " labia samples. ", n_abdo, " abdomen samples. (Total: ",n_abdo+n_labia+n_vagina,")" ))

```

We know that there are 120 samples, but here it's printing 117, because there are 3 instances where Abdomen are not found (written *abdomen*, or *Abdo*). This will be a headache when generate plots or statistics. We could change these manutally, but I'll write a function below which finds those errors and lets the user change the value. 

## Writing a function

Functions can be quite simple to write and easy to implement for simple repetitive tasks. For example, with single cell RNA analysis with Seurat, if you're testing different variables, having the workflow summarized in one function will make your workflow tidier. 

Here we're just going to write the checker above into a function with some extra user-input functionality. 

```{r}

sample_counter <- function(data){
  n_vagina = 0
  n_labia = 0
  n_abdo = 0
  
  for(index in 1:nrow(data)){ #loop from 1 through nrows in data (1,2,3...121,120) and assign this value to 'index'
    if(data$tissue[index] == "Abdomen"){ #check if the string at row[index] in the 'tissue' column matches abdomen. 
      n_abdo = n_abdo+1 #If so, add 1 to the variable. 
    } else if(data$tissue[index] == "Labia"){
      n_labia=n_labia+1
    } else if(data$tissue[index] == "Vagina"){
      n_vagina=n_vagina+1
    } else {
      print(paste(data$tissue[index], "at index",index,"does not match Abdomen, Labia or Vagina."))
      checkval=0
      while(checkval==0){
        input = readline("Choose correct value: [1] Abdomen, [2] Labia, [3] Vagina. ")
        if(input %in% c(1:3)) {
           if(input==1){
             n_abdo = n_abdo+1
             data$tissue[index] = "Abdomen"
           } else if(input==2) {
              n_labia=n_labia+1
              data$tissue[index] = "Labia"
  
           } else if(input==3) {
              n_vagina=n_vagina+1
              data$tissue[index] = "Vagina"
           }
           checkval = 1 #exit the while loop
        } else {
          cat("\nIncorrect input. Try again.\n")
        }
      }
    }
  }
  print(paste0(n_vagina, " vagina samples. ", n_labia, " labia samples. ", n_abdo, " abdomen samples. (Total: ",n_abdo+n_labia+n_vagina,")" ))
  return(data)
}

```

```{r, eval=F}
data <- sample_counter(data)
1
1
1
write.csv(data, "~/Desktop/analysis-user-group/synthetic_data.csv")
```

Throughout your analysis, you'll find more relevant for loops, while loops and functions that make you more efficient at programming. 

[Next chapter â†’](https://drthomasoneil.github.io/analysis-user-group/r-tutorial/_book/chapter-4-data-manipulation-with-tidyverse.html) 


<div id="quote-box" style="text-align:center; font-style:italic; margin-top:20px; margin-bottom:20px;"></div>
